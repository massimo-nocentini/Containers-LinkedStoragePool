{	"classes" : {		"Dictionary" : {			"hash" : 801024,			"definition" : "HashedCollection subclass: #Dictionary\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Dictionaries'",			"comment" : [				"I am a collection of elements that associate a key object with a value object.",				"",				"Description",				"--------------------------",				"",				"I  can be viewed from one of two perspectives: a set of associations, or a container of values that are externally named where the name can be any object that responds to #=. The external name is referred to as the key.  I inherit many operations from Set.",				"I use the #= method to locate a key. If you want a collection that use the #== method (same pointers) you can use an IdentityDictionary.",				"",				"I'm used when we need a collection of objects which I can access with a key. For example if you associate some words with a definition, the word will be the key and the definition will be the value. Both of them can be any kind of objects.",				"",				"Internally I use Associations. The Association class can help to use me. (See examples lower)",				"",				"Public API and Key Messages",				"--------------------------",				"",				"- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue \t\tallow to add an element.",				"  ",				"- #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock \t\tallow to access my values.",				"",				"- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: \t\tallow to iterate on me effectively",				"",				"Examples ",				"--------------------------",				"",				"To create a dictiony with indexes as key: ",				"",				"\tDictionary withAll: #(7 3 1 3)   \t\t\"returns:  a Dictionary(1->7 2->3 3->1 4->3 \"",				"",				"To use Objects as key (here symbols): ",				"",				"\tcolors := Dictionary new ",				"\t\t\t\tat: #yellow put: Color yellow; ",				"\t\t\t\tat: #blue put: Color blue;",				"\t\t\t\tat: #red put: Color red;",				"\t\t\t\tyourself.",				"\t\t\t\t",				"\tcolors at: #yellow. \t\"returns:  Color yellow\"",				"\tcolors keys          \"returns: a Set(#blue #yellow #red)\"",				"\tcolors values       \"returns:  {Color blue. Color yellow. Color red}\" ",				"",				"You can also directly use Associations: ",				"",				"\tcolors := Dictionary with: #yellow -> Color yellow with: #blue -> Color blue.",				"\tcolors add: #red -> Color red.",				"\t",				"\tcolors associations  \t\"returns: {#yellow->Color yellow. #red->Color red. #blue->Color blue}\"",				"\t\t",				"Here some more examples: ",				"",				"\tcolors := Dictionary newFrom: { #blue->Color blue . #red->Color red . #yellow->Color yellow }. ",				"\tcolors removeKey: #blue. ",				"\tcolors at: #red ifPresent: [ :color |  color darker] ifAbsent: [ Error signal: 'The red color should be here.' ] .\t\t\"return: (Color r: 0.92 g: 0.0 b: 0.0 alpha: 1.0)\"",				"\tcolors associations \t\t \"{#yellow->Color yellow. #red->Color red}\"",				" ",				"Internal Representation and Key Implementation Points.",				"--------------------------",				"",				"I am just a collection of associations. If I need my keys I will just return the keys of my associations. Idem for my values.",				"I use the #= method in order to manipulate my keys. I cannot have two associations that are equals with the #= method."			],			"category" : "Collections-Unordered-Dictionaries"		},		"CollectionTest" : {			"hash" : 3669504,			"definition" : "TestCase subclass: #CollectionTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Support-Tests-Base'",			"comment" : [				"Basic Collection tests"			],			"category" : "Collections-Support-Tests-Base"		},		"TopologicalSortAlgorithm" : {			"hash" : 2479872,			"definition" : "Object subclass: #TopologicalSortAlgorithm\r\tinstanceVariableNames: 'size relation'\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool-Examples-Topological sort'",			"comment" : [				"Implementation of the Algorithm T in TAOCP by Donald Knuth, Volume 1 page 264."			],			"category" : "Containers-LinkedStoragePool-Examples-Topological sort"		},		"Association" : {			"hash" : 790784,			"definition" : "LookupKey subclass: #Association\r\tinstanceVariableNames: 'value'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Support-Associations'",			"comment" : [				"I represent a pair of associated objects--a key and a value. My instances can serve as entries in a dictionary.",				"",				"",				"Implementation notes: ",				"Note that hash is not redefined even if the = was redefined because Association>>hash may cause extreme slowdowns in compiling Unicode methods. Association>>hash does not need to hash the value; it's slow and useless.",				""			],			"category" : "Collections-Support-Associations"		},		"ObjectTest" : {			"hash" : 3717888,			"definition" : "ClassTestCase subclass: #ObjectTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Tests-Objects'",			"comment" : [				"SUnit tests for objects"			],			"category" : "Kernel-Tests-Objects"		},		"DictionaryTest" : {			"hash" : 3680768,			"definition" : "CollectionRootTest subclass: #DictionaryTest\r\tuses: TIncludesTest + TDictionaryAddingTest + TDictionaryComparingTest + TDictionaryCopyingTest + TDictionaryEnumeratingTest + (TDictionaryPrintingTest - {#testPrintElementsOn. #testStoreOn}) + TDictionaryRemovingTest + (TPutBasicTest - {#testAtPutOutOfBounds}) + TAsStringCommaAndDelimiterTest + TPrintTest + TConvertTest + TConvertAsSortedTest + (TCopyTest - {#testCopyEmptyWithout. #testCopyNonEmptyWithout. #testCopyNonEmptyWithoutNotIncluded}) + TSetArithmetic + TDictionaryIncludesWithIdentityCheckTest + TDictionaryValueAccessTest + TDictionaryKeysValuesAssociationsAccess + TDictionaryKeyAccessTest + TDictionaryAssociationAccessTest + TStructuralEqualityTest + TOccurrencesForMultiplinessTest\r\tinstanceVariableNames: 'emptyDict nonEmptyDict nonEmpty5ElementsNoDuplicates indexArray valueArray nonEmpty1Element collectionNotIncluded collectionIncluded associationNotIn valueNotIn keyNotIn dictionaryNotIncluded dictionaryWithDuplicateValues duplicateValue nonEmptyWithString'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Tests-Dictionaries'",			"comment" : [				"SUnit tests for dictionaries"			],			"category" : "Collections-Unordered-Tests-Dictionaries"		},		"Object" : {			"hash" : 804608,			"definition" : "ProtoObject subclass: #Object\r\tinstanceVariableNames: ''\r\tclassVariableNames: 'DependentsFields'\r\tpackage: 'Kernel-Objects'",			"comment" : [				"`Object` is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.",				"",				"Class `Object` provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.",				"",				"`Object` has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.",				"",				"Class Variables:",				"\tDependentsFields\t\tan IdentityDictionary",				"\t\tProvides a virtual 'dependents' field so that any object may have one",				"\t\tor more dependent views, synchronized by the changed:/update: protocol.",				"\t\tNote that class Model has a real slot for its dependents, and overrides",				"\t\tthe associated protocol with more efficient implementations.",				"",				"Because `Object` is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.",				"",				"",				"###Miscellanous Discussions",				"",				"About `at:` index accepting float and not only integers",				" ",				"This behavior is also free in the sense that the failure code is only invoked when the primitive fails and so adds nothing to the cost of successful accesses, which are the high dynamic frequency operation.  It will also show up under",				"profiling if one is concerned about efficiency, and so isn't a hidden cost.",				"",				"It is also in keeping with Pharo's mixed mode/arbitrary precision",				"implicit coercion number system that one *can* use fractions or floats as",				"indices.  Stripping out coercions like this will make the system more brittle.  So ",				"please do *not* remove this hack.  I think it's a feature and a useful one.",				"",				"Can you give me an example that demonstrates the usefulness of this feature?",				"",				"```",				"| a r |",				"a := Array new: 10 withAll: 0.",				"r := Random new.",				"100 timesRepeat: [| v | v := r next * 10 + 1. a at: v put: (a at: v) + 1].",				"a",				"```",				"",				"i.e. I didn't have to provide an explicit rounding step.  That's useful.  But in general anywhere ",				"where an index is derived by some calculation not having to provide the rounding step could be ",				"useful/helpful/more concise.  e.g. (n roundTo: 0.1) * 10 vs ((n roundTo: 0.1) * 10) asInteger.",				"",				"Some thought went into the original choice.  It is not a hack but there by intent.  The integers are ",				"simply a subset of the reals and forcing the programmer to use them is favouring the machine ",				"above the programmer.",				"",				"But I think you should justify getting rid of it rather than my having to justify keeping it.  Getting ",				"rid of it risks breaking code.  If it is there but does not harm then why get rid of it?",				"",				"best Eliot Miranda "			],			"category" : "Kernel-Objects"		},		"SequenceableCollection" : {			"hash" : 855040,			"definition" : "Collection subclass: #SequenceableCollection\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Abstract-Base'",			"comment" : [				"I am an abstract superclass for collections that have a well-defined order associated with their elements. Thus each element is externally-named by integers referred to as indices."			],			"category" : "Collections-Abstract-Base"		}	},	"messages" : {		"sinksOfValueLinksTable:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"sinksOfValueLinksTable: table",						"",						"\t^ (1 to: size)",						"\t\t  foldr: [ :k :aValueLink | ",						"\t\t\t  (table at: k)",						"\t\t\t\t  ifSink: [ k ~~> aValueLink ]",						"\t\t\t\t  otherwise: [ aValueLink ]",						"\t\t\t\t  forTopologicalSortAlgorithm: self ]",						"\t\t  init: nil"					],					"body" : [						"^ (1 to: size)",						"\t  foldr: [ :k :aValueLink | ",						"\t\t  (table at: k)",						"\t\t\t  ifSink: [ k ~~> aValueLink ]",						"\t\t\t  otherwise: [ aValueLink ]",						"\t\t\t  forTopologicalSortAlgorithm: self ]",						"\t  init: nil"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [ ],					"hash" : 20313561,					"argumentNames" : [						"table"					]				}			}		},		"ignoreBlock:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"CTLinkedStoragePool>>#allocateOrReuseLink",				"CTLinkedStoragePoolCircular>>#pop",				"CTLinkedStoragePoolCircularDoubly>>#pop",				"CTLinkedStoragePoolPolynomial class>>#termAssociations:",				"CTLinkedStoragePoolQueue>>#pop",				"CTLinkedStoragePoolStack>>#pop",				"ObjectTest>>#testIgnoreBlock",				"TopologicalSortAlgorithm>>#handleCycleInValueLinksTable:do:",				"TopologicalSortAlgorithm>>#sortOn:sinksValueLink:valueLinksTable:"			],			"implementors" : {				"Object" : {					"sourceCode" : [						"ignoreBlock: aBlock",						"",						"\t\"I invoke the given block giving myself as argument if it needs to consume me.",						"\t Then I return my self discarding the value returned by the given block.\"",						"",						"\taBlock cull: self.",						"\t^ self"					],					"body" : [						"aBlock cull: self.",						"^ self"					],					"isTestMethod" : false,					"category" : "*Kernel-Extensions",					"comment" : [						"I invoke the given block giving myself as argument if it needs to consume me.",						"\t Then I return my self discarding the value returned by the given block."					],					"hash" : 18637973,					"argumentNames" : [						"aBlock"					]				}			}		},		"anyAssociation" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"DictionaryTest>>#testAnyAssociation",				"TopologicalSortAlgorithm>>#handleCycleInValueLinksTable:do:"			],			"implementors" : {				"Dictionary" : {					"sourceCode" : [						"anyAssociation",						"",						"\t\"I mimic the message `Collection>>#anyone` with respect to associations that I collect.\"",						"",						"\tself",						"\t\temptyCheck;",						"\t\tassociationsDo: [ :assoc | ^ assoc ]"					],					"body" : [						"self",						"\temptyCheck;",						"\tassociationsDo: [ :assoc | ^ assoc ]"					],					"isTestMethod" : false,					"category" : "*Collections-Unordered-Extensions",					"comment" : [						"I mimic the message `Collection>>#anyone` with respect to associations that I collect."					],					"hash" : 1595683,					"argumentNames" : [ ]				}			}		},		"testTopologicalSortOnCycleDo2" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc"			],			"implementors" : {				"CollectionTest" : {					"sourceCode" : [						"testTopologicalSortOnCycleDo2",						"",						"\t\"The following test is kept from https://upload.wikimedia.org/wikipedia/commons/0/03/Directed_acyclic_graph_2.svg.\"",						"",						"\tself",						"\t\tassert: ((1 to: 8)",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (1 -> 4).",						"\t\t\t\t\t\t (2 -> 4).",						"\t\t\t\t\t\t (2 -> 5).",						"\t\t\t\t\t\t (3 -> 5).",						"\t\t\t\t\t\t (3 -> 8).",						"\t\t\t\t\t\t (4 -> 6).",						"\t\t\t\t\t\t (4 -> 7).",						"\t\t\t\t\t\t (4 -> 8).",						"\t\t\t\t\t\t (5 -> 7) }",						"\t\t\t\t onCycleDo: [ Error signal ])",						"\t\tequals: #( 1 2 4 6 3 5 7 8 )"					],					"body" : [						"self",						"\tassert: ((1 to: 8)",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (1 -> 4).",						"\t\t\t\t\t (2 -> 4).",						"\t\t\t\t\t (2 -> 5).",						"\t\t\t\t\t (3 -> 5).",						"\t\t\t\t\t (3 -> 8).",						"\t\t\t\t\t (4 -> 6).",						"\t\t\t\t\t (4 -> 7).",						"\t\t\t\t\t (4 -> 8).",						"\t\t\t\t\t (5 -> 7) }",						"\t\t\t onCycleDo: [ Error signal ])",						"\tequals: #( 1 2 4 6 3 5 7 8 )"					],					"isTestMethod" : true,					"category" : "*Containers-LinkedStoragePool-Tests",					"comment" : [						"The following test is kept from https://upload.wikimedia.org/wikipedia/commons/0/03/Directed_acyclic_graph_2.svg."					],					"hash" : 4464948,					"argumentNames" : [ ]				}			}		},		"isAcyclicWithRespectToAssociations:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc"			],			"implementors" : {				"SequenceableCollection" : {					"sourceCode" : [						"isAcyclicWithRespectToAssociations: aRelation",						"",						"\t| isAcyclic |",						"\tisAcyclic := true.",						"\tself",						"\t\ttopologicalSortByAssociations: aRelation",						"\t\tonCycleDo: [ isAcyclic := false ].",						"\t^ isAcyclic"					],					"body" : [						"| isAcyclic |",						"isAcyclic := true.",						"self",						"\ttopologicalSortByAssociations: aRelation",						"\tonCycleDo: [ isAcyclic := false ].",						"^ isAcyclic"					],					"isTestMethod" : false,					"category" : "*Containers-LinkedStoragePool-Examples",					"comment" : [ ],					"hash" : 18951940,					"argumentNames" : [						"aRelation"					]				}			}		},		"testTopologicalSortOnCycleDo" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc"			],			"implementors" : {				"CollectionTest" : {					"sourceCode" : [						"testTopologicalSortOnCycleDo",						"",						"\t\"The following test is kept from TAOCP by Donald Knuth, Volume 1 page 272.\"",						"",						"\tself",						"\t\tassert: ((1 to: 9)",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (9 -> 2).",						"\t\t\t\t\t\t (3 -> 7).",						"\t\t\t\t\t\t (7 -> 5).",						"\t\t\t\t\t\t (5 -> 8).",						"\t\t\t\t\t\t (8 -> 6).",						"\t\t\t\t\t\t (4 -> 6).",						"\t\t\t\t\t\t (1 -> 3).",						"\t\t\t\t\t\t (7 -> 4).",						"\t\t\t\t\t\t (9 -> 5).",						"\t\t\t\t\t\t (2 -> 8) }",						"\t\t\t\t onCycleDo: [ Error signal ])",						"\t\tequals: #( 1 3 7 4 9 2 5 8 6 )"					],					"body" : [						"self",						"\tassert: ((1 to: 9)",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (9 -> 2).",						"\t\t\t\t\t (3 -> 7).",						"\t\t\t\t\t (7 -> 5).",						"\t\t\t\t\t (5 -> 8).",						"\t\t\t\t\t (8 -> 6).",						"\t\t\t\t\t (4 -> 6).",						"\t\t\t\t\t (1 -> 3).",						"\t\t\t\t\t (7 -> 4).",						"\t\t\t\t\t (9 -> 5).",						"\t\t\t\t\t (2 -> 8) }",						"\t\t\t onCycleDo: [ Error signal ])",						"\tequals: #( 1 3 7 4 9 2 5 8 6 )"					],					"isTestMethod" : true,					"category" : "*Containers-LinkedStoragePool-Tests",					"comment" : [						"The following test is kept from TAOCP by Donald Knuth, Volume 1 page 272."					],					"hash" : 4465181,					"argumentNames" : [ ]				}			}		},		"makeValueLinksTable" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"makeValueLinksTable",						"",						"\t\"COUNT: the number of direct predecessors of this object.\"",						"",						"\t\"TOP: link to the beginning of the list of direct successors of this object.\"",						"",						"\t^ (1 to: size) collect: [ :k | 0 -> nil ]"					],					"body" : [						"^ (1 to: size) collect: [ :k | 0 -> nil ]"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [						"COUNT: the number of direct predecessors of this object."					],					"hash" : 3274039,					"argumentNames" : [ ]				}			}		},		"topologicalSortByAssociations:acyclicDo:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"CollectionTest>>#testTopologicalSortOnCycleDo3"			],			"implementors" : {				"SequenceableCollection" : {					"sourceCode" : [						"topologicalSortByAssociations: aRelation acyclicDo: aBlock",						"",						"\t| ordering edges |",						"\tedges := Array streamContents: [ :aStream | ",						"\t\t         [ ",						"\t\t         | isAcyclic |",						"\t\t         isAcyclic := true.",						"\t\t         ordering := self",						"\t\t\t                     topologicalSortByAssociations: aRelation",						"\t\t\t                     onCycleDo: [ :sequence :cycle | ",						"\t\t\t\t                     | edge |",						"\t\t\t\t                     isAcyclic := false.",						"\t\t\t\t                     edge := cycle anyOne.",						"\t\t\t\t                     aStream nextPut: edge.",						"\t\t\t\t                     aRelation remove: edge.",						"\t\t\t\t                     sequence ].",						"\t\t         isAcyclic ] whileFalse ].",						"",						"\t^ aBlock value: ordering value: edges"					],					"body" : [						"| ordering edges |",						"edges := Array streamContents: [ :aStream | ",						"\t         [ ",						"\t         | isAcyclic |",						"\t         isAcyclic := true.",						"\t         ordering := self",						"\t\t                     topologicalSortByAssociations: aRelation",						"\t\t                     onCycleDo: [ :sequence :cycle | ",						"\t\t\t                     | edge |",						"\t\t\t                     isAcyclic := false.",						"\t\t\t                     edge := cycle anyOne.",						"\t\t\t                     aStream nextPut: edge.",						"\t\t\t                     aRelation remove: edge.",						"\t\t\t                     sequence ].",						"\t         isAcyclic ] whileFalse ].",						"",						"^ aBlock value: ordering value: edges"					],					"isTestMethod" : false,					"category" : "*Containers-LinkedStoragePool-Examples",					"comment" : [ ],					"hash" : 36253367,					"argumentNames" : [						"aRelation",						"aBlock"					]				}			}		},		"initializeValueLinksTable:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"initializeValueLinksTable: table",						"",						"\t\"T2: next relation.\"",						"",						"\trelation do: [ :anAssoc | ",						"\t\t| j k |",						"\t\t\"Unpack `relation` such that `relation = (j -> k)` holds.\"",						"\t\tj := anAssoc key.",						"\t\tk := anAssoc value.",						"",						"\t\t\"T3: Increase COUNT by one.\"",						"\t\t(table at: k) in: [ :destAssoc | destAssoc key: destAssoc key + 1 ].",						"",						"\t\t\"T3: record the relation.\"",						"\t\t(table at: j) in: [ :sourceAssoc | \"Operation (8)\" ",						"\t\t\tsourceAssoc value: k ~~> sourceAssoc value ] ]"					],					"body" : [						"relation do: [ :anAssoc | ",						"\t| j k |",						"\t\"Unpack `relation` such that `relation = (j -> k)` holds.\"",						"\tj := anAssoc key.",						"\tk := anAssoc value.",						"",						"\t\"T3: Increase COUNT by one.\"",						"\t(table at: k) in: [ :destAssoc | destAssoc key: destAssoc key + 1 ].",						"",						"\t\"T3: record the relation.\"",						"\t(table at: j) in: [ :sourceAssoc | \"Operation (8)\" ",						"\t\tsourceAssoc value: k ~~> sourceAssoc value ] ]"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [						"T2: next relation."					],					"hash" : 20313394,					"argumentNames" : [						"table"					]				}			}		},		"sortOn:sinksValueLink:valueLinksTable:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"sortOn: aStream sinksValueLink: qlink valueLinksTable: table",						"",						"\t| f |",						"\tf := qlink.",						"\t[ f ] whileNotNil: [ ",						"\t\t| aValueLink anIndex |",						"\t\t\"T5: output front of queue.\"",						"\t\tanIndex := f value.",						"\t\taStream nextPut: anIndex.",						"",						"\t\t\"T7: remove from queue.\"",						"\t\tf := f nextLink.",						"",						"\t\taValueLink := (table at: anIndex) in: [ :anAssoc | ",						"\t\t\t              anAssoc value ignoreBlock: [ anAssoc value: nil ] ].",						"",						"\t\t\"T6: erase relations.\"",						"\t\taValueLink do: [ :k | ",						"\t\t\t| kIndex |",						"\t\t\tkIndex := k value.",						"\t\t\t(table at: kIndex)",						"\t\t\t\tdecrementCountIfZero: [ f := kIndex ~~> f ]",						"\t\t\t\tforTopologicalSortAlgorithm: self ] ]"					],					"body" : [						"| f |",						"f := qlink.",						"[ f ] whileNotNil: [ ",						"\t| aValueLink anIndex |",						"\t\"T5: output front of queue.\"",						"\tanIndex := f value.",						"\taStream nextPut: anIndex.",						"",						"\t\"T7: remove from queue.\"",						"\tf := f nextLink.",						"",						"\taValueLink := (table at: anIndex) in: [ :anAssoc | ",						"\t\t              anAssoc value ignoreBlock: [ anAssoc value: nil ] ].",						"",						"\t\"T6: erase relations.\"",						"\taValueLink do: [ :k | ",						"\t\t| kIndex |",						"\t\tkIndex := k value.",						"\t\t(table at: kIndex)",						"\t\t\tdecrementCountIfZero: [ f := kIndex ~~> f ]",						"\t\t\tforTopologicalSortAlgorithm: self ] ]"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [ ],					"hash" : 54655543,					"argumentNames" : [						"aStream",						"qlink",						"table"					]				}			}		},		"testAnyAssociation" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc"			],			"implementors" : {				"DictionaryTest" : {					"sourceCode" : [						"testAnyAssociation",						"",						"\tself",						"\t\tshould: [ Dictionary new anyAssociation ]",						"\t\traise: CollectionIsEmpty.",						"",						"\tself",						"\t\tassert: (Dictionary new",						"\t\t\t\t at: 0 put: 1;",						"\t\t\t\t anyAssociation)",						"\t\tequals: 0 -> 1.",						"",						"\tself",						"\t\tassert: (Dictionary new",						"\t\t\t\t at: 0 put: 1;",						"\t\t\t\t at: 1 put: 2;",						"\t\t\t\t anyAssociation)",						"\t\tequals: 0 -> 1.",						"",						"\tself",						"\t\tassert: (Dictionary new",						"\t\t\t\t at: 0 put: 1;",						"\t\t\t\t at: 1 put: 2;",						"\t\t\t\t select: #even) anyAssociation",						"\t\tequals: 1 -> 2"					],					"body" : [						"self",						"\tshould: [ Dictionary new anyAssociation ]",						"\traise: CollectionIsEmpty.",						"",						"self",						"\tassert: (Dictionary new",						"\t\t\t at: 0 put: 1;",						"\t\t\t anyAssociation)",						"\tequals: 0 -> 1.",						"",						"self",						"\tassert: (Dictionary new",						"\t\t\t at: 0 put: 1;",						"\t\t\t at: 1 put: 2;",						"\t\t\t anyAssociation)",						"\tequals: 0 -> 1.",						"",						"self",						"\tassert: (Dictionary new",						"\t\t\t at: 0 put: 1;",						"\t\t\t at: 1 put: 2;",						"\t\t\t select: #even) anyAssociation",						"\tequals: 1 -> 2"					],					"isTestMethod" : true,					"category" : "*Containers-LinkedStoragePool-Tests",					"comment" : [ ],					"hash" : 4476848,					"argumentNames" : [ ]				}			}		},		"testTopologicalSortOnCycleDo3" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc"			],			"implementors" : {				"CollectionTest" : {					"sourceCode" : [						"testTopologicalSortOnCycleDo3",						"",						"\t\"This test case shows how to iteratively removing edges",						"\t belonging to a cycle to yield an acyclic relation.\"",						"",						"\t| aRelation m |",						"\tm := 100.",						"\taRelation := self randomRelationOfSize: 1000 max: m.",						"",						"\t(1 to: m)",						"\t\ttopologicalSortByAssociations: aRelation",						"\t\tacyclicDo: [ :ordering :edges | ",						"\t\t\tself",						"\t\t\t\tassert: ordering",						"\t\t\t\tequals:",						"\t\t\t\t\t#( 60 73 86 94 57 95 99 100 96 98 87 64 80 88 15 41 1 93 2 84 97",						"\t\t\t\t\t   89 67 75 7 82 92 81 90 63 76 37 66 4 50 70 71 77 9 42 72 68 65",						"\t\t\t\t\t   58 69 47 44 3 91 46 85 62 56 49 6 45 8 78 27 11 83 59 5 48 38",						"\t\t\t\t\t   39 79 16 30 74 34 40 19 53 24 20 14 12 51 13 33 25 26 23 36 35",						"\t\t\t\t\t   21 52 17 22 18 28 31 32 61 29 10 54 43 55 ).",						"",						"\t\t\tself assert_testTopologicalSortOnCycleDo3_edgesEqualsTo: edges ]"					],					"body" : [						"| aRelation m |",						"m := 100.",						"aRelation := self randomRelationOfSize: 1000 max: m.",						"",						"(1 to: m)",						"\ttopologicalSortByAssociations: aRelation",						"\tacyclicDo: [ :ordering :edges | ",						"\t\tself",						"\t\t\tassert: ordering",						"\t\t\tequals:",						"\t\t\t\t#( 60 73 86 94 57 95 99 100 96 98 87 64 80 88 15 41 1 93 2 84 97",						"\t\t\t\t   89 67 75 7 82 92 81 90 63 76 37 66 4 50 70 71 77 9 42 72 68 65",						"\t\t\t\t   58 69 47 44 3 91 46 85 62 56 49 6 45 8 78 27 11 83 59 5 48 38",						"\t\t\t\t   39 79 16 30 74 34 40 19 53 24 20 14 12 51 13 33 25 26 23 36 35",						"\t\t\t\t   21 52 17 22 18 28 31 32 61 29 10 54 43 55 ).",						"",						"\t\tself assert_testTopologicalSortOnCycleDo3_edgesEqualsTo: edges ]"					],					"isTestMethod" : true,					"category" : "*Containers-LinkedStoragePool-Tests",					"comment" : [						"This test case shows how to iteratively removing edges",						"\t belonging to a cycle to yield an acyclic relation."					],					"hash" : 4989170,					"argumentNames" : [ ]				}			}		},		"topologicalSortByAssociations:onCycleDo:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"CollectionTest>>#testTopologicalSortOnCycleDo2",				"CollectionTest>>#testTopologicalSortOnCycleDo1",				"CollectionTest>>#testTopologicalSortOnCycleDo",				"SequenceableCollection>>#isAcyclicWithRespectToAssociations:",				"SequenceableCollection>>#topologicalSortByAssociations:acyclicDo:"			],			"implementors" : {				"SequenceableCollection" : {					"sourceCode" : [						"topologicalSortByAssociations: aRelation onCycleDo: cBlock",						"",						"\t^ TopologicalSortAlgorithm new",						"\t\t  size: self size;",						"\t\t  relation: aRelation;",						"\t\t  value: [ :ordering | ",						"\t\t\t  self species streamContents: [ :aStream | ",						"\t\t\t\t\t  ordering do: [ :anIndex | aStream nextPut: (self at: anIndex) ] ] ]",						"\t\t  onCycleDo: [ :cycle | ",						"\t\t\t  | sequence |",						"\t\t\t  sequence := Array streamContents: [ :aStream | ",						"\t\t\t\t\t              aStream nextPut: (self at: cycle first key).",						"\t\t\t\t\t              cycle reverseDo: [ :anAssoc | ",						"\t\t\t\t\t\t\t              aStream nextPut: (self at: anAssoc key) ] ].",						"\t\t\t  cBlock cull: sequence cull: cycle ]"					],					"body" : [						"^ TopologicalSortAlgorithm new",						"\t  size: self size;",						"\t  relation: aRelation;",						"\t  value: [ :ordering | ",						"\t\t  self species streamContents: [ :aStream | ",						"\t\t\t\t  ordering do: [ :anIndex | aStream nextPut: (self at: anIndex) ] ] ]",						"\t  onCycleDo: [ :cycle | ",						"\t\t  | sequence |",						"\t\t  sequence := Array streamContents: [ :aStream | ",						"\t\t\t\t              aStream nextPut: (self at: cycle first key).",						"\t\t\t\t              cycle reverseDo: [ :anAssoc | ",						"\t\t\t\t\t\t              aStream nextPut: (self at: anAssoc key) ] ].",						"\t\t  cBlock cull: sequence cull: cycle ]"					],					"isTestMethod" : false,					"category" : "*Containers-LinkedStoragePool-Examples",					"comment" : [ ],					"hash" : 35729388,					"argumentNames" : [						"aRelation",						"cBlock"					]				}			}		},		"handleCycleInValueLinksTable:do:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"handleCycleInValueLinksTable: table do: cycleBlock",						"",						"\t| kk cycle qlink |",						"\t\"T9\"",						"\tqlink := Dictionary new.",						"\t1 to: size do: [ :k | ",						"\t\t| assoc p |",						"\t\tassoc := table at: k.",						"\t\tp := assoc value ignoreBlock: [ assoc value: 0 ].",						"",						"\t\t\"T10\"",						"\t\tp do: [ :each | qlink at: each value put: k ] ].",						"",						"\t\"T11\"",						"\tkk := qlink anyAssociation key.",						"",						"\t\"T12\"",						"\t[ ",						"\t(table at: kk) value: 1.",						"\tkk := qlink at: kk.",						"\t(table at: kk) value = 0 ] whileTrue.",						"",						"\t\"T13\"",						"\tcycle := Array streamContents: [ :aStream | ",						"\t\t         [ ",						"\t\t         aStream nextPut: kk.",						"\t\t         (table at: kk) value: 0.",						"\t\t         kk := qlink at: kk.",						"\t\t         (table at: kk) value = 1 ] whileTrue.",						"\t\t         aStream nextPut: kk ].",						"",						"\t\"Invoke the given block with the detected cycle.\"",						"\t^ cycleBlock value:",						"\t\t  (cycle overlappingPairsCollect: [ :a :b | b -> a ])"					],					"body" : [						"| kk cycle qlink |",						"\"T9\"",						"qlink := Dictionary new.",						"1 to: size do: [ :k | ",						"\t| assoc p |",						"\tassoc := table at: k.",						"\tp := assoc value ignoreBlock: [ assoc value: 0 ].",						"",						"\t\"T10\"",						"\tp do: [ :each | qlink at: each value put: k ] ].",						"",						"\"T11\"",						"kk := qlink anyAssociation key.",						"",						"\"T12\"",						"[ ",						"(table at: kk) value: 1.",						"kk := qlink at: kk.",						"(table at: kk) value = 0 ] whileTrue.",						"",						"\"T13\"",						"cycle := Array streamContents: [ :aStream | ",						"\t         [ ",						"\t         aStream nextPut: kk.",						"\t         (table at: kk) value: 0.",						"\t         kk := qlink at: kk.",						"\t         (table at: kk) value = 1 ] whileTrue.",						"\t         aStream nextPut: kk ].",						"",						"\"Invoke the given block with the detected cycle.\"",						"^ cycleBlock value:",						"\t  (cycle overlappingPairsCollect: [ :a :b | b -> a ])"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [ ],					"hash" : 39189868,					"argumentNames" : [						"table",						"cycleBlock"					]				}			}		},		"ifSink:otherwise:forTopologicalSortAlgorithm:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"TopologicalSortAlgorithm>>#sinksOfValueLinksTable:"			],			"implementors" : {				"Association" : {					"sourceCode" : [						"ifSink: sBlock otherwise: oBlock forTopologicalSortAlgorithm: aTSA",						"",						"\t^ key ifZero: sBlock ifNotZero: oBlock"					],					"body" : [						"^ key ifZero: sBlock ifNotZero: oBlock"					],					"isTestMethod" : false,					"category" : "*Containers-LinkedStoragePool-Examples",					"comment" : [ ],					"hash" : 52702662,					"argumentNames" : [						"sBlock",						"oBlock",						"aTSA"					]				}			}		},		"testTopologicalSortOnCycleDo1" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc"			],			"implementors" : {				"CollectionTest" : {					"sourceCode" : [						"testTopologicalSortOnCycleDo1",						"",						"\t\"This test stress four small cycles detection.\"",						"",						"\t| cycleBlock |",						"\tcycleBlock := [ :sequence :cycle | sequence , cycle ].",						"\tself",						"\t\tassert: ({ #a }",						"\t\t\t\t topologicalSortByAssociations: { (1 -> 1) }",						"\t\t\t\t onCycleDo: cycleBlock)",						"\t\tequals: { ",						"\t\t\t\t#a.",						"\t\t\t\t#a.",						"\t\t\t\t(1 -> 1) }.",						"\tself",						"\t\tassert: ({ #a. #b }",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t\t (2 -> 1) }",						"\t\t\t\t onCycleDo: cycleBlock)",						"\t\tequals: { ",						"\t\t\t\t#b.",						"\t\t\t\t#a.",						"\t\t\t\t#b.",						"\t\t\t\t(2 -> 1).",						"\t\t\t\t(1 -> 2) }.",						"\tself",						"\t\tassert: ({ #a. #b. #c }",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t\t (2 -> 3).",						"\t\t\t\t\t\t (3 -> 1) }",						"\t\t\t\t onCycleDo: cycleBlock)",						"\t\tequals: { ",						"\t\t\t\t#c.",						"\t\t\t\t#a.",						"\t\t\t\t#b.",						"\t\t\t\t#c.",						"\t\t\t\t(3 -> 1).",						"\t\t\t\t(2 -> 3).",						"\t\t\t\t(1 -> 2) }.",						"\tself",						"\t\tassert: ({ #a. #b. #c. #d. #e }",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (5 -> 1).",						"\t\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t\t (2 -> 3).",						"\t\t\t\t\t\t (3 -> 5).",						"\t\t\t\t\t\t (3 -> 4) }",						"\t\t\t\t onCycleDo: cycleBlock)",						"\t\tequals: { ",						"\t\t\t\t#e.",						"\t\t\t\t#a.",						"\t\t\t\t#b.",						"\t\t\t\t#c.",						"\t\t\t\t#e.",						"\t\t\t\t(5 -> 1).",						"\t\t\t\t(3 -> 5).",						"\t\t\t\t(2 -> 3).",						"\t\t\t\t(1 -> 2) }"					],					"body" : [						"| cycleBlock |",						"cycleBlock := [ :sequence :cycle | sequence , cycle ].",						"self",						"\tassert: ({ #a }",						"\t\t\t topologicalSortByAssociations: { (1 -> 1) }",						"\t\t\t onCycleDo: cycleBlock)",						"\tequals: { ",						"\t\t\t#a.",						"\t\t\t#a.",						"\t\t\t(1 -> 1) }.",						"self",						"\tassert: ({ #a. #b }",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t (2 -> 1) }",						"\t\t\t onCycleDo: cycleBlock)",						"\tequals: { ",						"\t\t\t#b.",						"\t\t\t#a.",						"\t\t\t#b.",						"\t\t\t(2 -> 1).",						"\t\t\t(1 -> 2) }.",						"self",						"\tassert: ({ #a. #b. #c }",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t (2 -> 3).",						"\t\t\t\t\t (3 -> 1) }",						"\t\t\t onCycleDo: cycleBlock)",						"\tequals: { ",						"\t\t\t#c.",						"\t\t\t#a.",						"\t\t\t#b.",						"\t\t\t#c.",						"\t\t\t(3 -> 1).",						"\t\t\t(2 -> 3).",						"\t\t\t(1 -> 2) }.",						"self",						"\tassert: ({ #a. #b. #c. #d. #e }",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (5 -> 1).",						"\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t (2 -> 3).",						"\t\t\t\t\t (3 -> 5).",						"\t\t\t\t\t (3 -> 4) }",						"\t\t\t onCycleDo: cycleBlock)",						"\tequals: { ",						"\t\t\t#e.",						"\t\t\t#a.",						"\t\t\t#b.",						"\t\t\t#c.",						"\t\t\t#e.",						"\t\t\t(5 -> 1).",						"\t\t\t(3 -> 5).",						"\t\t\t(2 -> 3).",						"\t\t\t(1 -> 2) }"					],					"isTestMethod" : true,					"category" : "*Containers-LinkedStoragePool-Tests",					"comment" : [						"This test stress four small cycles detection."					],					"hash" : 4727868,					"argumentNames" : [ ]				}			}		},		"decrementCountIfZero:forTopologicalSortAlgorithm:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"TopologicalSortAlgorithm>>#sortOn:sinksValueLink:valueLinksTable:"			],			"implementors" : {				"Association" : {					"sourceCode" : [						"decrementCountIfZero: zBlock forTopologicalSortAlgorithm: aTSA",						"",						"\t^ (key := key - 1) ifZero: zBlock"					],					"body" : [						"^ (key := key - 1) ifZero: zBlock"					],					"isTestMethod" : false,					"category" : "*Containers-LinkedStoragePool-Examples",					"comment" : [ ],					"hash" : 35663645,					"argumentNames" : [						"zBlock",						"aTSA"					]				}			}		},		"value:onCycleDo:" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc",				"SequenceableCollection>>#topologicalSortByAssociations:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"value: aBlock onCycleDo: cycleBlock",						"",						"\t| table sort qlink |",						"\ttable := self makeValueLinksTable.",						"",						"\t\"T1: initialize. T4: scan for zeros.\"",						"\tqlink := self",						"\t\t         initializeValueLinksTable: table;",						"\t\t         sinksOfValueLinksTable: table.",						"",						"\tsort := Array streamContents: [ :aStream | ",						"\t\t        self",						"\t\t\t        sortOn: aStream",						"\t\t\t        sinksValueLink: qlink",						"\t\t\t        valueLinksTable: table ].",						"",						"\t^ sort size < size",						"\t\t  ifTrue: [ self handleCycleInValueLinksTable: table do: cycleBlock ]",						"\t\t  ifFalse: [ aBlock value: sort ]"					],					"body" : [						"| table sort qlink |",						"table := self makeValueLinksTable.",						"",						"\"T1: initialize. T4: scan for zeros.\"",						"qlink := self",						"\t         initializeValueLinksTable: table;",						"\t         sinksOfValueLinksTable: table.",						"",						"sort := Array streamContents: [ :aStream | ",						"\t        self",						"\t\t        sortOn: aStream",						"\t\t        sinksValueLink: qlink",						"\t\t        valueLinksTable: table ].",						"",						"^ sort size < size",						"\t  ifTrue: [ self handleCycleInValueLinksTable: table do: cycleBlock ]",						"\t  ifFalse: [ aBlock value: sort ]"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [ ],					"hash" : 38142151,					"argumentNames" : [						"aBlock",						"cycleBlock"					]				}			}		},		"testIgnoreBlock" : {			"senders" : [				"BaselineOfContainersLinkedStoragePool>>#scriptTopologicalSortMessagesForDoc",				"BaselineOfContainersLinkedStoragePool>>#scriptValueLinkMessagesForDoc"			],			"implementors" : {				"ObjectTest" : {					"sourceCode" : [						"testIgnoreBlock",						"",						"\t| var |",						"\tself",						"\t\tassert: (3 ignoreBlock: [ 3 + 4 ]) equals: 3;",						"\t\tassert: (3 + 4 ignoreBlock: [ :seven | seven + 5 ]) equals: 7.",						"",						"\t\"#ignoreBlock: can be used to return a value that is bound to a variable ",						"\t that immediately has to be updated, as follows:\"",						"\tvar := 7.",						"\tself",						"\t\tassert: (var ignoreBlock: [ var := var + 1 ]) equals: 7;",						"\t\tassert: var equals: 8"					],					"body" : [						"| var |",						"self",						"\tassert: (3 ignoreBlock: [ 3 + 4 ]) equals: 3;",						"\tassert: (3 + 4 ignoreBlock: [ :seven | seven + 5 ]) equals: 7.",						"",						"\"#ignoreBlock: can be used to return a value that is bound to a variable ",						"\t that immediately has to be updated, as follows:\"",						"var := 7.",						"self",						"\tassert: (var ignoreBlock: [ var := var + 1 ]) equals: 7;",						"\tassert: var equals: 8"					],					"isTestMethod" : true,					"category" : "*Containers-LinkedStoragePool-Tests",					"comment" : [ ],					"hash" : 4776403,					"argumentNames" : [ ]				}			}		}	}}